# regatta

![Version: 0.2.3](https://img.shields.io/badge/Version-0.2.3-informational?style=flat-square) ![Type: application](https://img.shields.io/badge/Type-application-informational?style=flat-square) ![AppVersion: 0.2.1](https://img.shields.io/badge/AppVersion-0.2.1-informational?style=flat-square)

Regatta is a distributed key-value store. Regatta is designed as easy to deploy, kubernetes friendly with emphasis
on high read throughput and low operational cost.

**Homepage:** <https://engineering.jamf.com/regatta>

## Maintainers

| Name | Email | Url |
| ---- | ------ | --- |
| coufalja |  |  |
| jsfpdn |  |  |

## Requirements

Kubernetes: `>= 1.21.0`

## Values

| Key | Type | Default | Description |
|-----|------|---------|-------------|
| additionalPodLabels | object | `{}` | additionalPodLabels: Optional map of additional pod labels |
| api.externalLoadBalancer | object | `{"annotations":{},"enabled":false,"externalDomain":"regatta.example.com","loadBalancerSourceRanges":[]}` | externalLoadBalancer: If enabled, the Service of type LoadBalancer is created # ref: https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer |
| api.externalLoadBalancer.annotations | object | `{}` | annotations: Service annotations |
| api.externalLoadBalancer.enabled | bool | `false` | enabled: true/false |
| api.externalLoadBalancer.externalDomain | string | `"regatta.example.com"` | externalDomain: External Regatta API domain name |
| api.externalLoadBalancer.loadBalancerSourceRanges | list | `[]` | loadBalancerSourceRanges: external access whitelist, available on AWS only # ref: https://kubernetes.io/docs/concepts/services-networking/service/#aws-nlb-support |
| api.port | int | `8443` | port: gRPC API port |
| api.tls.cert | string | `"plaintext server certificate\n"` | cert: TLS cert in plaintext Note: applicable only if `mode: plaintext` |
| api.tls.issuerRef | object | `{}` | issuerRef: IssuerRef configuration that is passed to the Certificate object   Note: applicable only if `mode: certificate` |
| api.tls.key | string | `"plaintext server certificate key\n"` | key: TLS key in plaintext Note: applicable only if `mode: plaintext` |
| api.tls.mode | string | `"auto"` | mode:    May be one of:    - auto: the certificate is generated at the installation time, this is not safe    - certificate: the certificate is generated by `cert-manager.io/v1/Certificate` object    - plaintext: enter `cert` and `key` content directly into values    - none: no certificate nor secret is created, you need to provide a secret separately      Secret example:        apiVersion: v1       kind: Secret       metadata:         name: regatta-api-cert       data:         tls.crt: Y2xpZW50LWNlcnQK         tls.key: Y2xpZW50LWtleQo= |
| cluster.port | int | `7432` | port: Memberlist port for incoming cluster coordination comms. |
| dragonboatSoftSettings | string | `"{\n  \"TaskBatchSize\": 128,\n  \"PerConnectionSendBufSize\": 10485760,\n  \"MaxConcurrentStreamingSnapshot\": 1\n}\n"` | dragonboatSoftSettings: ref: https://github.com/lni/dragonboat/blob/v3.3.6/internal/settings/soft.go#L27 |
| fullnameOverride | string | `""` | fullnameOverride: String to fully override `"regatta.fullname"` |
| image.imagePullPolicy | string | `"IfNotPresent"` | imagePullPolicy: ref: https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy |
| image.repository | string | `"ghcr.io/jamf/regatta"` | repository: Default image repository |
| image.tag | string | `"v0.2.1"` | tag: Override to use different image version |
| imagePullSecrets | list | `[]` | imagePullSecrets: For the Regatta image |
| maintenance.backup | object | `{"bucket":"s3-bucket-name","enabled":false,"failedJobsHistoryLimit":2,"schedule":"0 */4 * * *","successfulJobsHistoryLimit":4}` | Controls the creation of the backup CronJob that uses the Regatta maintenance API Note: the `maintenance.server.enabled` must be set to `true` |
| maintenance.backup.bucket | string | `"s3-bucket-name"` | bucket: Address of the s3 bucket where to upload backup |
| maintenance.backup.enabled | bool | `false` | enabled: Enable the backup CronJob   Note: the maintenance server must be enabled |
| maintenance.backup.failedJobsHistoryLimit | int | `2` | failedJobsHistoryLimit: CronJob config field |
| maintenance.backup.schedule | string | `"0 */4 * * *"` | schedule: Cron expression defining how often the backup is executed |
| maintenance.backup.successfulJobsHistoryLimit | int | `4` | successfulJobsHistoryLimit: CronJob config field |
| maintenance.secretKind | string | `"plaintext"` | secretKind   May be one of:   - sealedSecret: Use if you have SealedSecrets support on your cluster. (https://sealed-secrets.netlify.app/)   - plaintext: Use to create Opaque Secret from the plaintext.   - none: Do not create the secret with the token at all. The secret must be provided externally.      Secret example:         apiVersion: v1        kind: Secret        metadata:          name: regatta-maintenance-token        data:          token: c2VjcmV0LXRva2Vu  |
| maintenance.server.enabled | bool | `false` | enabled: Maintenance API enabled |
| maintenance.server.port | int | `8445` | port: Port of maintenance server to listen on |
| maintenance.server.tls.cert | string | `"plaintext server certificate\n"` | cert: TLS certificate in plaintext   Note: Applicable only if `mode: plaintext` |
| maintenance.server.tls.issuerRef | object | `{}` | issuerRef: issuerRef configuration that is passed to the Certificate object   Note: Applicable only if `mode: certificate` |
| maintenance.server.tls.key | string | `"plaintext server certificate key\n"` | key: TLS key in plaintext Note: Applicable only if `mode: plaintext` |
| maintenance.server.tls.mode | string | `"auto"` | mode:    May be one of:    - auto: the certificate is generated at the installation time, this is not safe    - certificate: the certificate is generated by `cert-manager.io/v1/Certificate` object    - plaintext: enter `cert` and `key` content directly into values    - none: no certificate nor secret is created, you need to provide a secret separately      Secret example:        apiVersion: v1       kind: Secret       metadata:         name: regatta-maintenance-cert       data:         tls.crt: Y2xpZW50LWNlcnQK         tls.key: Y2xpZW50LWtleQo= |
| maintenance.token | string | `"secret-token"` | token:   Depending on value of `secretKind`     - sealedSecret: enter the encrypted value     - plaintext: enter the plaintext secret value     - none: the field is ignored |
| metricsPort | int | `8079` | metricsPort: Regatta metrics port |
| mode | string | `"leader"` | mode: Regatta mode   Can be either leader or follower. |
| nameOverride | string | `""` | nameOverride: Provide a name in place of `regatta`. |
| nodeSelector | object | `{}` | nodeSelector: Map of nodeSelector labels for the Regatta pods # ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector |
| persistentVolumeClaim.spec | object | `{"accessModes":["ReadWriteOnce"],"resources":{"requests":{"storage":"10Gi"}}}` | spec: The full content of the persistentVolumeClaim.spec |
| podAnnotations | object | `{}` | podAnnotations: Optional map of pod annotations |
| podAntiAffinity.enabled | bool | `false` | enabled: Enable or disable the pod anti-affinity |
| podAntiAffinity.topologyKey | string | `"kubernetes.io/hostname"` | topologyKey: Use to override the topologyKey value |
| podDisruptionBudget.enabled | bool | `false` | enabled: If true, the pdb object is created |
| podDisruptionBudget.minAvailable | int | `2` | minAvailable: Sets the minAvailable field of the pdb object |
| priorityClassName | string | `""` | priorityClassName: Defines the priorityClassName of the Regatta pods.   Leave empty string if you don't want to use this feature. # ref: https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/ |
| prometheusRules.enabled | bool | `false` | enabled: PrometheusRule object created if true |
| prometheusRules.groups | list | `[]` | groups: List of the PrometheusRule groups |
| raft.compactionOverhead | int | `5000` | compactionOverhead: Defines the number of most recent entries to keep after each Raft log compaction.   Raft log compaction is performed automatically every time when a snapshot is created. |
| raft.electionRTT | int | `100` | electionRTT: The minimum number of message RTT between elections. Message RTT is defined by raft.rtt.   The Raft paper suggests it to be a magnitude greater than heartbeatRTT, which is the interval between two heartbeats.   In Raft, the actual interval between elections is randomized to be between electionRTT and 2 * electionRTT.   As an example, assuming raft.rtt is 100 millisecond, to set the election interval to be 1 second,   then electionRTT should be set to 10. |
| raft.heartbeatRTT | int | `4` | heartbeatRTT: The number of message RTT between heartbeats. Message RTT is defined by raft.rtt.   The Raft paper suggest the heartbeat interval to be close to the average RTT between nodes.   As an example, assuming raft.rtt is 100 millisecond, to set the heartbeat interval to be every 200 milliseconds,   then heartbeatRTT should be set to 2. |
| raft.logdb | string | `"tan"` | logdb: Defines the implementation to use for LogDB store. Options are pebble (legacy) or tan (default).    tan is less space efficient but significantly better at both memory and cpu usage.    This option currently cannot be changed after cluster is started without restoring data from snapshot or backup. |
| raft.maxInMemLogSize | int | `6291456` | maxInMemLogSize is the target size in bytes allowed for storing in memory Raft logs on each Raft node.   In memory Raft logs are the ones that have not been applied yet. |
| raft.maxRecvQueueSize | int | `0` | maxReceiveQueueSize is the maximum size in bytes of each receive queue. Once the maximum size is reached,   further replication messages will be dropped to restrict memory usage.   When set to 0, it means the queue size is unlimited. |
| raft.maxSendQueueSize | int | `0` | maxSendQueueSize is the maximum size in bytes of each send queue. Once the maximum size is reached,   further replication messages will be dropped to restrict memory usage.   When set to 0, it means the send queue size is unlimited. |
| raft.port | int | `5012` | port: Port number for internal communication, cannot be changed after cluster startup. |
| raft.rtt | string | `"50ms"` | rtt: Defines the average Round Trip Time (RTT) between two NodeHost instances.   Such an RTT interval is internally used as a logical clock tick, Raft heartbeat and election intervals   are both defined in terms of how many such RTT intervals. Note that RTTMillisecond is the combined delays   between two NodeHost instances including all delays caused by network transmission,   delays caused by NodeHost queuing and processing.   Specified as Go's duration string (https://pkg.go.dev/maze.io/x/duration#ParseDuration). |
| raft.snapshotEntries | int | `10000` | snapshotEntries: SnapshotEntries defines how often the state machine should be snapshotted automatically.   It is defined in terms of the number of applied Raft log entries. |
| raft.snapshotRecoveryType | string | `"checkpoint"` | snapshotRecoveryType is the implementation of internal Raft snapshotting mechanism. Options are snapshot (legacy) or checkpoint (default). |
| readinessProbe | object | `{"failureThreshold":3,"initialDelaySeconds":5,"periodSeconds":30,"successThreshold":1,"timeoutSeconds":5}` | startupProbe: Defines the readinessProbe for the Regatta container # ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-readiness-probes |
| reflectionAPI.enabled | bool | `false` | enabled: Whether reflection API is provided. Should be false on in production. |
| replicas | int | `1` | replicas: Defines number of Regatta replicas   Note: This value must match the number of raft initial members `raft.initialMembers`. |
| replication.leaderAddress | string | `"leader.regatta.example.com"` | leaderAddress: The address of the leader to replicate from Note: Applicable only if the Regatta mode is follower (`mode: follower`) |
| replication.logCacheSize | int | `0` | logCacheSize: The replication server log cache size. 0 means the cache is turned off. |
| replication.logRpcTimeout | string | `"5m"` | logRpcTimeout: The log RPC timeout. |
| replication.maxSnapshotRecvBytesPerSecond | int | `0` | maxSnapshotRecvBytesPerSecond: Maximum number of bytes received per second by the snapshot API client,   default value 0 means unlimited. |
| replication.server | object | `{"enabled":false,"externalDomain":"leader.regatta.example.com","port":8444,"serviceAnnotations":{}}` | server: The replication server may be used when Regatta is in the leader mode (`mode: leader`).   Follower Regatta replicates data from this server. |
| replication.server.enabled | bool | `false` | enabled: Enables the replication server |
| replication.server.externalDomain | string | `"leader.regatta.example.com"` | externalDomain: |
| replication.server.port | int | `8444` | port: Replication server port |
| replication.server.serviceAnnotations | object | `{}` | serviceAnnotations: Replication server LoadBalancer service annotations |
| replication.tls.ca | string | `"plaintext server ca\n"` | cert: CA in plaintext Note: Applicable only if `mode: plaintext` |
| replication.tls.cert | string | `"plaintext server certificate\n"` | cert: TLS certificate in plaintext Note: Applicable only if `mode: plaintext` |
| replication.tls.issuerRef | object | `{}` | issuerRef: issuerRef configuration that is passed to the Certificate object Note: applicable only if `mode: certificate` |
| replication.tls.key | string | `"plaintext server certificate key\n"` | key: TLS key in plaintext Note: Applicable only if `mode: plaintext` |
| replication.tls.mode | string | `"auto"` | mode:    May be one of:    - auto: the certificate is generated at the installation time, this is not safe    - certificate: the certificate is generated by `cert-manager.io/v1/Certificate` object    - plaintext: enter `cert` and `key` content directly into values    - none: no certificate nor secret is created, you need to provide a secret separately      Secret example:        apiVersion: v1       kind: Secret       metadata:         name: regatta-replication-cert       data:         tls.crt: Y2xpZW50LWNlcnQK         tls.key: Y2xpZW50LWtleQo= |
| resources | object | `{}` | resources: Define the resources of the pods |
| securityContext | object | `{"allowPrivilegeEscalation":false,"capabilities":{"drop":["ALL"]},"privileged":false}` | securityContext: The full content of the container.securityContext |
| serviceAccount.create | bool | `true` | create: Create the ServiceAccount for regatta |
| serviceAccount.name | string | `""` | name: ServiceAccount name override, default: `"regatta.fullname"` |
| serviceMonitorEnabled | bool | `false` | serviceMonitorEnabled: ServiceMonitor object is created if set to true |
| startupProbe | object | `{"failureThreshold":3,"initialDelaySeconds":90,"periodSeconds":60,"successThreshold":1,"timeoutSeconds":5}` | startupProbe: Defines the startupProbe for the Regatta container # ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-startup-probes |
| storage.blockCacheSize | int | `796917760` | blockCacheSize: Shared block cache size in bytes. The cache is used to hold uncompressed blocks of data in memory |
| tables | string | `"table-1,table-2"` | tables: Comma separated list of Regatta tables |
| temp.enabled | bool | `false` | enabled: Set to true to enable tmp EmptyDir. |
| temp.medium | string | `nil` | medium: Set to `Memory` to place temp into tmpfs |
| temp.sizeLimit | string | `nil` | sizeLimit: Size constraint for temp file system |
| tolerations | list | `[]` | tolerations: Defines tolerations for the Regatta pods # ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/ |

----------------------------------------------
Autogenerated from chart metadata using [helm-docs v1.11.0](https://github.com/norwoodj/helm-docs/releases/v1.11.0)
